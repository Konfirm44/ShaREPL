@*@page "/console"*@
@using System.Diagnostics
@using System.Threading.Tasks
@implements IDisposable

<style>
    .console-input {
        display: flex;
        align-items: flex-end;
    }

    .console-input input {
        width: 100%;
        border: none;
        outline: none;
        font-family: monospace;
        background-color: transparent;
    }

    .console-output {
        white-space: pre-wrap;
        font-family: monospace;
    }
</style>

<div class="console" @onclick="Click">
    <div class="console-output">
            @_output
    </div>
    <div class="console-input">
        <input type="text" @ref="inputRef" @bind="_input" @onkeydown="OnInputKeyDown" @oninput="OnInput" />
    </div>
</div>

@code {
private ElementReference inputRef;
private Process? _process;
private string _input = "";
private string _output = "";

public async Task OnInputKeyDown(KeyboardEventArgs e)
{
    if (e.Key is "Enter")
    {
        var inp = Input;
        Input = "";
        await SendInput(inp);
    }
}

private async Task Click()
{
    await inputRef.FocusAsync();
}

private void OnInput(ChangeEventArgs e)
{
    _input = e.Value?.ToString() ?? "";
    StateHasChanged();
}

protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        // Start the process
        _process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "cmd.exe",
                    UseShellExecute = false,
                    RedirectStandardInput = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = false
                }
            };
        _process.Start();

        // Read the output asynchronously
        await Task.Factory.StartNew(() =>
        {
            while (!_process.StandardOutput.EndOfStream)
            {
                string line = _process.StandardOutput.ReadLine() + "\n";
                InvokeAsync(() => Output += line);
            }
        });
    }
}

public void Dispose()
{
    // Close the process
    _process?.StandardInput.Close();
    _process?.WaitForExit();
    _process?.Close();
}

private async Task SendInput(string input)
{
    _process?.StandardInput.WriteLine(input);

    await Task.Factory.StartNew(() =>
    {
        while (!(_process?.StandardOutput.EndOfStream ?? true))
        {
            string line = _process.StandardOutput.ReadLine() + "\n";
            InvokeAsync(() => Output += line);
        }
    });
}

public string Output
{
    get => _output;
    set
    {
        _output = value;
        StateHasChanged();
    }
}

public string Input
{
    get => _input;
    set
    {
        _input = value;
        StateHasChanged();
    }
}
}